<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Minecraft MVP</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; user-select: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid white; transform: translate(-50%, -50%); border-radius: 50%; pointer-events: none; z-index: 2; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        
        /* Stats */
        #stats-container { position: absolute; bottom: 80px; left: 20px; color: white; text-shadow: 2px 2px 0 #000; }
        .bar-wrap { width: 200px; height: 20px; background: #333; margin-bottom: 5px; border: 2px solid white; position: relative; }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #hp-bar { background: #ff3333; width: 100%; }
        #hunger-bar { background: #ff9933; width: 100%; }
        
        /* Hotbar */
        #hotbar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; pointer-events: auto; }
        .slot { width: 50px; height: 50px; background: rgba(0,0,0,0.5); border: 2px solid #555; display: flex; justify-content: center; align-items: center; color: white; font-size: 12px; position: relative; }
        .slot.active { border-color: white; background: rgba(0,0,0,0.7); }
        .slot span { pointer-events: none; }
        .count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: yellow; }

        /* Crafting Menu (Hidden by default) */
        #menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; height: 400px; background: rgba(0,0,0,0.9); border: 4px solid #888; pointer-events: auto; color: white; padding: 20px; z-index: 10; }
        #menu h2 { margin-top: 0; text-align: center; }
        .craft-grid { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
        .recipe { width: 120px; height: 80px; background: #444; border: 1px solid #999; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; font-size: 12px; }
        .recipe:hover { background: #666; }
        .recipe small { color: #aaa; margin-top: 4px; font-size: 10px; }

        /* Instructions */
        #blocker { position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; flex-direction: column; color: white; z-index: 20; }
    </style>
</head>
<body>

    <!-- UI Elements -->
    <div id="crosshair"></div>
    
    <div id="blocker">
        <h1>MINECRAFT MVP</h1>
        <p>Click to Start</p>
        <p>WASD to Move | Space to Jump | Click to Break/Attack | Right Click to Place</p>
        <p>E for Crafting | F to Eat</p>
    </div>

    <div id="ui-layer">
        <div id="stats-container">
            <div>Health</div>
            <div class="bar-wrap"><div id="hp-bar" class="bar-fill"></div></div>
            <div>Hunger</div>
            <div class="bar-wrap"><div id="hunger-bar" class="bar-fill"></div></div>
            <div id="debug">Day 1 - 12:00 PM</div>
        </div>

        <div id="hotbar">
            <!-- Generated via JS -->
        </div>
    </div>

    <div id="menu">
        <h2>Crafting & Inventory</h2>
        <div class="craft-grid" id="recipe-list"></div>
        <div style="text-align: center; margin-top: 20px; color: #aaa;">Press E to Close</div>
    </div>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

        // --- GAME CONFIGURATION ---
        const WORLD_SIZE = 40; // Size of generated area
        const CHUNK_HEIGHT = 10;
        const BLOCK_SIZE = 1;
        
        // Block IDs
        const B_AIR = 0, B_DIRT = 1, B_GRASS = 2, B_STONE = 3, B_WOOD = 4, B_LEAVES = 5, B_PLANKS = 6, B_CRAFTING = 7, B_FURNACE = 8, B_TORCH = 9;
        
        // Colors for MVP textures
        const BLOCK_COLORS = [
            0x000000, 0x8B4513, 0x55aa55, 0x888888, 0x5c4033, 0x228B22, 0xd2b48c, 0xc19a6b, 0x555555, 0xffff00
        ];

        // --- STATE ---
        let camera, scene, renderer, controls;
        let raycaster, moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        let worldData = {}; // Stores block positions "x,y,z" -> type
        let meshes = []; // Stores mesh references for removal
        let interactableObjects = []; // Blocks and Mobs

        // Survival State
        let player = {
            health: 100,
            hunger: 100,
            inventory: { 1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0, 'coal':0, 'pork':0, 'cooked_pork':0 }, // Block IDs + Items
            tools: { pickaxe: false, axe: false, sword: false },
            selectedSlot: 0,
            hotbar: [0, 0, 0, 0, 0] // Stores Block IDs or String IDs (e.g., 'sword')
        };
        
        let mobs = [];
        let isDay = true;
        let timeOfDay = 0; // 0 to 1
        let lightSun, lightAmbient;

        // --- INIT ---
        init();
        animate();

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 10;

            // Lights
            lightAmbient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(lightAmbient);

            lightSun = new THREE.DirectionalLight(0xffffff, 0.8);
            lightSun.position.set(50, 100, 50);
            lightSun.castShadow = true;
            scene.add(lightSun);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            const blocker = document.getElementById('blocker');
            
            blocker.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => { blocker.style.display = 'none'; });
            controls.addEventListener('unlock', () => { 
                if(document.getElementById('menu').style.display !== 'flex') blocker.style.display = 'flex'; 
            });

            // Input Handling
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);

            // Raycaster
            raycaster = new THREE.Raycaster();

            // Generate World
            generateWorld();
            updateUI();
        }

        // --- WORLD GENERATION ---
        function generateWorld() {
            const noise = new ImprovedNoise();
            const geometry = new THREE.BoxGeometry(1, 1, 1);

            for (let x = -WORLD_SIZE/2; x < WORLD_SIZE/2; x++) {
                for (let z = -WORLD_SIZE/2; z < WORLD_SIZE/2; z++) {
                    // Terrain Height
                    let y = Math.floor(Math.abs(noise.noise(x / 20, 0, z / 20) * 10));
                    
                    // Base Terrain
                    for(let h = -2; h <= y; h++) {
                        let type = (h === y) ? B_GRASS : (h < y - 3 ? B_STONE : B_DIRT);
                        createBlock(x, h, z, type);
                    }

                    // Trees (Procedural)
                    if (y > 0 && Math.random() < 0.05) {
                        createTree(x, y + 1, z);
                    }
                }
            }
        }

        function createBlock(x, y, z, type, isMesh = true) {
            const key = `${x},${y},${z}`;
            if (worldData[key]) return; // Already exists

            worldData[key] = type;

            if (isMesh) {
                const material = new THREE.MeshLambertMaterial({ color: BLOCK_COLORS[type] });
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), material);
                mesh.position.set(x, y, z);
                mesh.userData = { type: type, isBlock: true };
                scene.add(mesh);
                interactableObjects.push(mesh);
                meshes.push(mesh);
            }
        }

        function createTree(x, y, z) {
            // Trunk
            for(let i=0; i<4; i++) createBlock(x, y+i, z, B_WOOD);
            // Leaves
            for(let lx=x-2; lx<=x+2; lx++) {
                for(let lz=z-2; lz<=z+2; lz++) {
                    for(let ly=y+2; ly<=y+3; ly++) {
                        if(Math.abs(lx-x) + Math.abs(lz-z) < 3) {
                             if(!worldData[`${lx},${ly},${lz}`]) createBlock(lx, ly, lz, B_LEAVES);
                        }
                    }
                }
            }
        }

        // --- GAME LOGIC ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += 15; canJump = false; break;
                case 'Digit1': selectHotbar(0); break;
                case 'Digit2': selectHotbar(1); break;
                case 'Digit3': selectHotbar(2); break;
                case 'Digit4': selectHotbar(3); break;
                case 'Digit5': selectHotbar(4); break;
                case 'KeyE': toggleMenu(); break;
                case 'KeyF': eatFood(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseDown(event) {
            if (!controls.isLocked) return;

            // 0 = Left (Break/Attack), 2 = Right (Place)
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects(interactableObjects);

            if (intersects.length > 0 && intersects[0].distance < 5) {
                const hit = intersects[0];
                const obj = hit.object;

                if (event.button === 0) {
                    // LEFT CLICK
                    if (obj.userData.isMob) {
                        damageMob(obj);
                    } else if (obj.userData.isBlock) {
                        breakBlock(obj);
                    }
                } else if (event.button === 2) {
                    // RIGHT CLICK
                    const heldItem = player.hotbar[player.selectedSlot];
                    
                    // Interact with Furnace/Crafting? (Simplified for MVP: Just placing)
                    
                    if (heldItem && typeof heldItem === 'number' && heldItem > 0) {
                        // Place Block
                        const p = hit.point.add(hit.face.normal.multiplyScalar(0.5)).floor();
                        // Prevent placing inside player
                        const dist = new THREE.Vector3(p.x, p.y, p.z).distanceTo(camera.position);
                        if(dist > 1.5) {
                            createBlock(p.x, p.y, p.z, heldItem);
                            removeFromInventory(heldItem, 1);
                        }
                    }
                }
            }
        }

        // --- MECHANICS ---

        function breakBlock(mesh) {
            const type = mesh.userData.type;
            let breakTime = 1;
            
            // Tool Logic
            const tool = player.hotbar[player.selectedSlot];
            if (type === B_STONE && tool === 'pickaxe') breakTime = 0.2;
            else if (type === B_WOOD && tool === 'axe') breakTime = 0.2;
            else if (type === B_STONE && tool !== 'pickaxe') breakTime = 5; // Hard to break stone by hand

            // For MVP, instant break if tool is right or block is soft
            scene.remove(mesh);
            const key = `${mesh.position.x},${mesh.position.y},${mesh.position.z}`;
            delete worldData[key];
            interactableObjects.splice(interactableObjects.indexOf(mesh), 1);
            
            // Add to inventory
            let drop = type;
            if(type === B_LEAVES) drop = (Math.random() > 0.8) ? 'apple' : 0; // Rare apple
            if(type === B_STONE) drop = B_STONE; // Simple cobblestone logic
            
            addToInventory(drop, 1);
        }

        function createMob(type) {
            const geo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            const color = type === 'zombie' ? 0x00ff00 : 0xcccccc; // Green Zombie, Grey Skeleton
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const mob = new THREE.Mesh(geo, mat);
            
            // Random spawn pos away from player
            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 10;
            const x = camera.position.x + Math.cos(angle) * dist;
            const z = camera.position.z + Math.sin(angle) * dist;
            
            mob.position.set(x, 10, z); // Start high, fall down
            mob.userData = { isMob: true, type: type, health: 3, velocity: new THREE.Vector3() };
            
            scene.add(mob);
            interactableObjects.push(mob);
            mobs.push(mob);
        }

        function damageMob(mob) {
            const tool = player.hotbar[player.selectedSlot];
            let damage = 1;
            if(tool === 'sword') damage = 3;
            if(tool === 'axe') damage = 2;

            mob.userData.health -= damage;
            mob.material.color.setHex(0xff0000); // Flash red
            setTimeout(() => {
                if(mob.userData.type === 'zombie') mob.material.color.setHex(0x00ff00);
                else mob.material.color.setHex(0xcccccc);
            }, 100);

            if(mob.userData.health <= 0) {
                scene.remove(mob);
                mobs.splice(mobs.indexOf(mob), 1);
                interactableObjects.splice(interactableObjects.indexOf(mob), 1);
                addToInventory('pork', 1); // Reward
            }
        }

        function updateMobs(delta) {
            mobs.forEach(mob => {
                const dist = mob.position.distanceTo(camera.position);
                
                // Gravity
                mob.position.y -= 0.1;
                // Simple collision floor
                if(mob.position.y < 1) mob.position.y = 1; // Floor clamp for MVP

                // AI
                if(dist < 15) {
                    const dir = new THREE.Vector3().subVectors(camera.position, mob.position).normalize();
                    dir.y = 0;
                    mob.position.add(dir.multiplyScalar(2 * delta)); // Move speed
                    mob.lookAt(camera.position);

                    // Attack Player
                    if(dist < 1.5) {
                        player.health -= 0.5;
                        updateUI();
                    }
                }
            });
        }

        // --- INVENTORY & CRAFTING ---
        function addToInventory(item, count) {
            if(!item) return;
            if (player.inventory[item] !== undefined) {
                player.inventory[item] += count;
            } else {
                player.inventory[item] = count;
            }
            updateUI();
        }

        function removeFromInventory(item, count) {
            if (player.inventory[item] >= count) {
                player.inventory[item] -= count;
                if(player.inventory[item] <= 0 && typeof item !== 'string') player.inventory[item] = 0; 
                updateUI();
                return true;
            }
            return false;
        }

        function selectHotbar(index) {
            player.selectedSlot = index;
            updateUI();
        }

        function eatFood() {
            const item = player.hotbar[player.selectedSlot];
            if(item === 'apple' || item === 'cooked_pork') {
                if(player.hunger < 100) {
                    player.hunger = Math.min(100, player.hunger + 20);
                    player.health = Math.min(100, player.health + 10);
                    removeFromInventory(item, 1);
                }
            }
        }

        // CRAFTING RECIPES
        const recipes = [
            { name: 'Planks (4)', cost: { [B_WOOD]: 1 }, result: { id: B_PLANKS, count: 4 } },
            { name: 'Sticks (4)', cost: { [B_PLANKS]: 2 }, result: { id: 'stick', count: 4 } },
            { name: 'Craft Table', cost: { [B_PLANKS]: 4 }, result: { id: B_CRAFTING, count: 1 } },
            { name: 'Pickaxe', cost: { [B_PLANKS]: 3, 'stick': 2 }, result: { id: 'pickaxe', count: 1 } },
            { name: 'Sword', cost: { [B_PLANKS]: 2, 'stick': 1 }, result: { id: 'sword', count: 1 } },
            { name: 'Axe', cost: { [B_PLANKS]: 3, 'stick': 2 }, result: { id: 'axe', count: 1 } },
            { name: 'Torches (4)', cost: { 'stick': 1, [B_STONE]: 1 }, result: { id: B_TORCH, count: 4 } }, // Coal simplified to stone for MVP
            { name: 'Furnace', cost: { [B_STONE]: 8 }, result: { id: B_FURNACE, count: 1 } },
            { name: 'Cook Pork', cost: { 'pork': 1, [B_WOOD]: 1 }, result: { id: 'cooked_pork', count: 1 } }
        ];

        function toggleMenu() {
            const menu = document.getElementById('menu');
            if (menu.style.display === 'block') {
                menu.style.display = 'none';
                controls.lock();
            } else {
                menu.style.display = 'block';
                controls.unlock();
                renderRecipes();
            }
        }

        function renderRecipes() {
            const container = document.getElementById('recipe-list');
            container.innerHTML = '';
            recipes.forEach(r => {
                const div = document.createElement('div');
                div.className = 'recipe';
                div.innerHTML = `<b>${r.name}</b>`;
                div.onclick = () => craft(r);
                container.appendChild(div);
            });
            
            // Add inventory to hotbar slots logic could go here, 
            // but for MVP hotbar is auto-filled or static mapping.
            // Simplified: Auto-equip tools/blocks to hotbar if space exists
        }

        function craft(recipe) {
            // Check costs
            for(let key in recipe.cost) {
                if((player.inventory[key] || 0) < recipe.cost[key]) return; // Not enough
            }
            // Consume
            for(let key in recipe.cost) {
                removeFromInventory(key, recipe.cost[key]);
            }
            // Add result
            addToInventory(recipe.result.id, recipe.result.count);
            
            // Auto-equip logic for MVP
            const id = recipe.result.id;
            if(!player.hotbar.includes(id) && player.hotbar.includes(0)) {
                player.hotbar[player.hotbar.indexOf(0)] = id;
            }
            updateUI();
        }

        // --- UI UPDATER ---
        function updateUI() {
            document.getElementById('hp-bar').style.width = player.health + '%';
            document.getElementById('hunger-bar').style.width = player.hunger + '%';
            
            const hb = document.getElementById('hotbar');
            hb.innerHTML = '';
            player.hotbar.forEach((item, idx) => {
                const div = document.createElement('div');
                div.className = `slot ${idx === player.selectedSlot ? 'active' : ''}`;
                
                let name = '';
                if(item === 0) name = '';
                else if(typeof item === 'string') name = item.charAt(0).toUpperCase(); // "S" for sword
                else name = 'B' + item; // Block ID

                // Pretty names
                if(item === 'pickaxe') name = 'PICK';
                if(item === 'sword') name = 'SWRD';
                if(item === 'axe') name = 'AXE';
                if(item === B_WOOD) name = 'LOG';
                if(item === B_STONE) name = 'COBB';
                
                div.innerHTML = `<span>${name}</span>`;
                if(typeof item === 'number' && item > 0) {
                     div.innerHTML += `<div class="count">${player.inventory[item] || 0}</div>`;
                }
                hb.appendChild(div);
            });
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                // Physics / Movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 30.0 * delta; // Gravity

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                controls.getObject().position.y += (velocity.y * delta);

                // Simple Floor Collision
                let playerHeight = 1.6;
                let px = Math.floor(controls.getObject().position.x);
                let pz = Math.floor(controls.getObject().position.z);
                
                // Raycast down for ground check
                let py = controls.getObject().position.y;
                if (py < 2) { // Flat floor safety
                    velocity.y = 0;
                    controls.getObject().position.y = 2;
                    canJump = true;
                }
            }

            // Day/Night Cycle
            timeOfDay += delta * 0.01; // Speed
            const sunY = Math.sin(timeOfDay) * 100;
            const sunX = Math.cos(timeOfDay) * 100;
            lightSun.position.set(sunX, sunY, 50);
            
            isDay = sunY > 0;
            scene.background.setHSL(0.6, 0.5, isDay ? 0.6 : 0.05);
            lightAmbient.intensity = isDay ? 0.6 : 0.1;

            const timeStr = isDay ? "Day" : "Night";
            document.getElementById('debug').innerText = `${timeStr} | Mobs: ${mobs.length}`;

            // Mob Spawning
            if (!isDay && mobs.length < 5 && Math.random() < 0.01) {
                createMob(Math.random() > 0.5 ? 'zombie' : 'skeleton');
            }
            updateMobs(delta);

            // Hunger
            if (Math.random() < 0.001) {
                player.hunger -= 1;
                updateUI();
                if(player.hunger <= 0) player.health -= 1;
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
